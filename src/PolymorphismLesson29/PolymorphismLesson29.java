package PolymorphismLesson29;

public class PolymorphismLesson29 {
    public static void main(String[] args) {
        Animal animal = new Dog();  // здесь мы рассматриваем собаку как животное
        animal.eat();

        Dog dog = new Dog();       // здесь мы рассматриваем собаку как собаку
        dog.eat();
        dog.bark();


        Animal animal1 = new Dog();
        animal1.eat();                                    // переопределение метода родительского класса Animal случилось, будет вызван метод потомка




        Animal animal2= new Animal();
        Dog dog1 = new Dog();
        Cat cat = new Cat();

        test(animal2);
        test(dog1);
        test(cat);

    }

    public static void test(Animal animal){               // создаём метод , который принимает в метод животное , переменную класса Animal
        animal.eat();                                       // можем делать, так у любого животного имеется метод eat()
    }
}
/* Полиморфизм - перевод с древнегреческого это множество форм, многообразие форм
В it полиморфизм - это способность метода обрабатывать данные разных типов
В классе Animal создадим метод eat(), метод который есть у всех животных
В классе Dog мы унаследуемся от класса Animal, теперь класс Dog является животным , так как он унаследовался от этого класса
Обратите внимание, что у объекта класса Dog есть метод eat() только потому, что мы унаследовались от класса Animal

Вместо того, чтобы создавать новый объект класса Animal давайте создадим новый  объект класса Dog
Animal animal = new Dog();

Если мы уберём наследование , то сразу же появится ошибка , что типы несовместимы
Наследование позволяет нам делать такую вещь , и в этом проявляется одна из сторон полиморфизма , то есть к объекту класса Dog можем
обращаться через переменную  родительского типа, но это имеет некоторые ограничения

Animal animal = new Dog();


 */
/* Ограничение полиморфизма
Создадим ещё один объект класса Dog, но через переменную типа Dog будем обращаться к ней
В классе Dog определим какой-то метод, который принадлежит только собаке, не всем животным в частности, а только собаке, метод лаять

public class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking...");
    }
}

Когда мы обратились к объекту класса Dog через переменную типа Animal, мы имеем доступ к методу eat(), который определён в классе Animal, но мы не имеем доступа к методу bark()
А когда создаём через тип Dog, то можно обратиться к методам Dog и Animal
А когда создаём через Animal, то можем обращаться к методам которые определены в Animal (в родителе)
 */
/* Позднее связывание
у нас есть метод eat() , сейчас он вызывается у объекта Dog  и он определён у его родителя , у класса Animal
но что будет , если в классе Dog переопределим этот метод
В итоге выведется то, что определено в потомке

  Animal animal = new Dog();
      animal.eat();

ТО есть несмотря на то, что мы эту собаку воспринимаем просто как животное общее, всегда вызывается тот метод, который определён в потомке, если такой имеется
Это и называется поздним связыванием, поэтому тип Animal он лишь определяет ограничение тех методов, которые мы можем вызвать, но сама реализация методов
если она есть в потомке, то она и будет вызвана, если ёё нет, реализации метода, то будет вызвана та реализация, которая есть у родителя
 */
/* Возможность передавать в метод разные типы, если у них есть один и тот же родитель*/
